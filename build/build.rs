use heck::ShoutySnakeCase;
use heck::SnakeCase;
use std::collections::HashMap;
use std::fs;
use std::io;
use std::io::prelude::*;
use std::path;

#[allow(unused)]
mod xproto;

struct Extra {
    xcb_type_map: HashMap<String, String>,
    xcb_enum_map: HashMap<String, String>,
    xlib_name_map: HashMap<String, String>,
}

const XCB_TYPE_MAP_PATH: &'static str = "xcb-type-map.txt";
const XCB_ENUM_MAP_PATH: &'static str = "xcb-enum-map.txt";
const XLIB_NAME_MAP_PATH: &'static str = "xlib-name-map.txt";
const XPROTO_XML_PATH: &'static str = "proto/src/xproto.xml";

impl Extra {
    pub fn new() -> io::Result<Self> {
        return Ok(Extra {
            xcb_type_map: load_map(XCB_TYPE_MAP_PATH)?,
            xcb_enum_map: load_map(XCB_ENUM_MAP_PATH)?,
            xlib_name_map: load_map(XLIB_NAME_MAP_PATH)?,
        });

        fn load_map<P: AsRef<path::Path> + ?Sized>(
            path: &P,
        ) -> io::Result<HashMap<String, String>> {
            let mut map: HashMap<String, String> = HashMap::new();
            for line in io::BufReader::new(fs::File::open(path).unwrap()).lines() {
                let line = line?;
                let line = line.trim_end();
                if line == "" || line.starts_with("#") {
                    continue;
                }
                let mut part_iter = line.split(" ");
                let from = part_iter.next().unwrap();
                let to = part_iter.next().unwrap();
                assert_eq!(part_iter.next(), None);
                map.insert(from.to_string(), to.to_string());
            }
            Ok(map)
        }
    }

    pub fn get_xcb_type_name(&self, name: &str) -> String {
        let auto_name = format!("xcb_{}_t", name.to_snake_case());
        match self.xcb_type_map.get(name) {
            Some(found_name) => {
                if &auto_name == found_name {
                    println!(
                        "cargo:warning=Unnecessary name override for {} in {}.",
                        name, XCB_TYPE_MAP_PATH
                    );
                    auto_name
                } else {
                    found_name.to_string()
                }
            }
            None => auto_name,
        }
    }

    pub fn get_xcb_enum_name(&self, name: &str) -> String {
        let auto_name = format!("xcb_{}_t", name.to_snake_case());
        match self.xcb_enum_map.get(name) {
            Some(found_name) => {
                if &auto_name == found_name {
                    println!(
                        "cargo:warning=Unnecessary name override for {} in {}.",
                        name, XCB_ENUM_MAP_PATH
                    );
                    auto_name
                } else {
                    found_name.to_string()
                }
            }
            None => auto_name,
        }
    }

    pub fn get_xlib_name<'a>(&'a self, name: &'a str) -> &'a str {
        match self.xlib_name_map.get(name) {
            Some(ref name) => name,
            None => {
                println!("cargo:warning=Could not find xlib name for {}.", name);
                name
            }
        }
    }
}

fn main() {
    println!(r#"cargo:rerun-if-changed="{}""#, XCB_TYPE_MAP_PATH);
    println!(r#"cargo:rerun-if-changed="{}""#, XCB_ENUM_MAP_PATH);
    println!(r#"cargo:rerun-if-changed="{}""#, XLIB_NAME_MAP_PATH);
    println!(r#"cargo:rerun-if-changed="{}""#, XPROTO_XML_PATH);

    let extra = Extra::new().unwrap();

    let root: xproto::Root =
        serde_xml_rs::from_reader(io::BufReader::new(fs::File::open(XPROTO_XML_PATH).unwrap()))
            .unwrap();

    let mut out = io::BufWriter::new(fs::File::create("src/lib.rs").unwrap());

    out.write_all(
        br##"// This file is automatically generated.

#![allow(non_camel_case_types)]

"##,
    )
    .unwrap();

    for typedef in root.items.iter().filter_map(xproto::RootItem::as_typedef) {
        write_typedef(&mut out, &extra, &typedef).unwrap();
    }

    for xid_type in root.items.iter().filter_map(xproto::RootItem::as_xid_type) {
        write_xid_type(&mut out, &extra, &xid_type).unwrap();
    }

    writeln!(out).unwrap();

    for xid_union in root.items.iter().filter_map(xproto::RootItem::as_xid_union) {
        write_xid_union(&mut out, &extra, &xid_union).unwrap();
    }

    for union in root.items.iter().filter_map(xproto::RootItem::as_union) {
        write_union(&mut out, &extra, &union).unwrap();
    }

    for enum_ in root.items.iter().filter_map(xproto::RootItem::as_enum) {
        write_enum(&mut out, &extra, &enum_).unwrap();
    }

    for struct_ in root.items.iter().filter_map(xproto::RootItem::as_struct) {
        write_struct(&mut out, &extra, &struct_).unwrap();
    }

    for item in root.items.iter() {
        let event;

        let event_ref = match *item {
            xproto::RootItem::Event(ref event) => event,
            xproto::RootItem::EventCopy(ref event_copy) => {
                let source_event = root
                    .items
                    .iter()
                    .filter_map(xproto::RootItem::as_event)
                    .find(|event| event.name == event_copy.source)
                    .unwrap_or_else(|| {
                        panic!(
                            "Could not find source event for event copy {:?}.",
                            event_copy
                        );
                    });
                event = xproto::Event {
                    name: event_copy.name.clone(),
                    code: event_copy.code,
                    items: source_event.items.clone(),
                };
                &event
            }
            _ => continue,
        };

        write_event(&mut out, &extra, event_ref).unwrap();
    }

    for error in root.items.iter().filter_map(xproto::RootItem::as_error) {
        write_error(&mut out, &extra, &error).unwrap();
    }

    for error_copy in root.items.iter().filter_map(xproto::RootItem::as_error_copy) {
        write_error_copy(&mut out, &extra, &error_copy).unwrap();
    }
}

fn write_typedef<W: io::Write>(
    out: &mut W,
    extra: &Extra,
    typedef: &xproto::Typedef,
) -> io::Result<()> {
    writeln!(
        out,
        "pub type {alias} = {ty};",
        alias = extra.get_xcb_type_name(&typedef.alias),
        // NOTE(mickvangelderen): We assume the type definitions are simple.
        ty = extra.get_xcb_type_name(&typedef.ty)
    )?;
    Ok(())
}

fn write_xid_type<W: io::Write>(
    out: &mut W,
    extra: &Extra,
    xid_type: &xproto::XIDType,
) -> io::Result<()> {
    writeln!(
        out,
        "pub type {xcb_name} = {xlib_name};",
        xcb_name = extra.get_xcb_type_name(&xid_type.name),
        xlib_name = extra.get_xlib_name(&xid_type.name)
    )?;
    Ok(())
}

fn write_xid_union<W: io::Write>(
    out: &mut W,
    extra: &Extra,
    xid_union: &xproto::XIDUnion,
) -> io::Result<()> {
    let union_name = extra.get_xcb_type_name(&xid_union.name);
    writeln!(
        out,
        r##"#[repr(C)]
pub union {name} {{"##,
        name = union_name
    )?;
    for ty in &xid_union.types {
        let xcb_ty = extra.get_xcb_type_name(ty);
        let field = &xcb_ty[4..xcb_ty.len() - 2];
        writeln!(out, "    pub {field}: {ty},", ty = xcb_ty, field = field)?;
    }
    writeln!(
        out,
        r##"}}
"##,
    )?;
    Ok(())
}

fn write_union<W: io::Write>(out: &mut W, extra: &Extra, union: &xproto::Union) -> io::Result<()> {
    let union_name = extra.get_xcb_type_name(&union.name);
    writeln!(
        out,
        r##"#[repr(C)]
pub union {name} {{"##,
        name = union_name
    )?;
    for item in &union.items {
        let ty = extra.get_xcb_type_name(&item.ty);
        writeln!(
            out,
            "    pub {name}: [{ty}; {count}],",
            ty = ty,
            name = item.name,
            count = item.count
        )?;
    }
    writeln!(
        out,
        r##"}}
"##,
    )?;
    Ok(())
}

fn write_enum<W: io::Write>(out: &mut W, extra: &Extra, enum_: &xproto::Enum) -> io::Result<()> {
    let enum_name = extra.get_xcb_enum_name(&enum_.name);
    let prefix = format!("XCB_{}", enum_.name.to_shouty_snake_case());

    writeln!(out, r"pub type {} = u32;", enum_name)?;

    for variant in enum_.variants.iter() {
        let vari_name = variant.name.to_shouty_snake_case();
        match &variant.item {
            xproto::VariantItem::Value(value) => {
                writeln!(
                    out,
                    "pub const {prefix}_{vari_name}: {enum_name} = {value};",
                    enum_name = enum_name,
                    prefix = prefix,
                    vari_name = vari_name,
                    value = value,
                )?;
            }
            xproto::VariantItem::Bit(shift) => {
                writeln!(
                    out,
                    "pub const {prefix}_{vari_name}: {enum_name} = 1 << {shift};",
                    enum_name = enum_name,
                    prefix = prefix,
                    vari_name = vari_name,
                    shift = shift,
                )?;
            }
        }
    }

    writeln!(out)?;

    Ok(())
}

fn write_struct<W: io::Write>(
    out: &mut W,
    extra: &Extra,
    struct_: &xproto::Struct,
) -> io::Result<()> {
    let struct_name = extra.get_xcb_type_name(&struct_.name);

    let mut pad_index = 0;
    writeln!(
        out,
        r##"
#[repr(C)]
pub struct {name} {{"##,
        name = struct_name
    )?;
    for item in struct_.items.iter() {
        match item {
            xproto::StructItem::Field(field) => {
                let field_ty = extra.get_xcb_type_name(&field.ty);
                writeln!(
                    out,
                    "    pub {name}: {ty},",
                    name = field.name,
                    ty = field_ty
                )?;
            }
            xproto::StructItem::Pad(pad) => {
                if let Some(ref bytes) = pad.bytes {
                    writeln!(
                        out,
                        "    pub _pad{index}: [u8; {bytes}],",
                        index = pad_index,
                        bytes = bytes
                    )?;
                    pad_index += 1;
                }
                if let Some(_) = pad.align {
                    // NOTE(mickvangelderen): align property is not documented
                    // in the xproto xml specification and it seems like the
                    // padding already properly aligns the fields. Could verify
                    // this but that would mean recursively determining the
                    // sizes of the fields which would make this script a lot
                    // more complicated.
                    println!("cargo:warning=Ignored align on {}.", struct_name);
                }
            }
            xproto::StructItem::List(_) => {
                // TODO: Do something with list?
                writeln!(out, "    // list")?;
            }
        }
    }
    writeln!(
        out,
        r##"}}
"##
    )?;
    Ok(())
}

fn write_event<W: io::Write>(out: &mut W, extra: &Extra, event: &xproto::Event) -> io::Result<()> {
    let code_name = format!("XCB_{}", event.name.to_shouty_snake_case());
    let event_name = format!("xcb_{}_event_t", event.name.to_snake_case());
    let mut pad_index = 0;

    writeln!(
        out,
        r##"pub const {code_name}: u8 = {code};

#[repr(C)]
pub struct {event_name} {{"##,
        code_name = code_name,
        code = event.code,
        event_name = event_name,
    )?;

    for item in event.items.iter() {
        match item {
            xproto::EventItem::Field(field) => {
                // NOTE(mickvangelderen): Don't want to make a file and hash map
                // and everything just for this one exception.
                // TODO(mickvangelderen): Should have one function somewhere to
                // determine the identifier for a type, a field name, etc.
                let field_name = if field.name == "type" {
                    "ty"
                } else {
                    &field.name
                };

                let field_ty = extra.get_xcb_type_name(&field.ty);
                writeln!(
                    out,
                    "    pub {name}: {ty},",
                    name = field_name,
                    ty = field_ty,
                )?;
            }
            xproto::EventItem::Pad(pad) => {
                if let Some(ref bytes) = pad.bytes {
                    writeln!(
                        out,
                        "    pub _pad{index}: [u8; {bytes}],",
                        index = pad_index,
                        bytes = bytes
                    )?;
                    pad_index += 1;
                }
                if let Some(_) = pad.align {
                    // NOTE(mickvangelderen): align property is not documented
                    // in the xproto xml specification and it seems like the
                    // padding already properly aligns the fields. Could verify
                    // this but that would mean recursively determining the
                    // sizes of the fields which would make this script a lot
                    // more complicated.
                    println!("cargo:warning=Ignored align on {}.", event_name);
                }
            }
            xproto::EventItem::List(_) => {
                // TODO: Do something with list?
                writeln!(out, "    // list")?;
            }
            xproto::EventItem::Doc(_) => {
                // NOTE(mickvangelderen): For now just refer to the not so great
                // c documentation.
            }
        }
    }

    writeln!(
        out,
        r"}}
"
    )?;
    Ok(())
}

fn write_error<W: io::Write>(out: &mut W, extra: &Extra, error: &xproto::Error) -> io::Result<()> {
    let code_name = format!("XCB_{}", error.name.to_shouty_snake_case());
    let error_name = format!("xcb_{}_error_t", error.name.to_snake_case());
    let mut pad_index = 0;

    writeln!(
        out,
        r##"pub const {code_name}: u8 = {code};

#[repr(C)]
pub struct {error_name} {{"##,
        code_name = code_name,
        code = error.code,
        error_name = error_name,
    )?;

    for item in error.items.iter() {
        match item {
            xproto::ErrorItem::Field(field) => {
                // NOTE(mickvangelderen): Don't want to make a file and hash map
                // and everything just for this one exception.
                // TODO(mickvangelderen): Should have one function somewhere to
                // determine the identifier for a type, a field name, etc.
                let field_name = if field.name == "type" {
                    "ty"
                } else {
                    &field.name
                };

                let field_ty = extra.get_xcb_type_name(&field.ty);
                writeln!(
                    out,
                    "    pub {name}: {ty},",
                    name = field_name,
                    ty = field_ty,
                )?;
            }
            xproto::ErrorItem::Pad(pad) => {
                if let Some(ref bytes) = pad.bytes {
                    writeln!(
                        out,
                        "    pub _pad{index}: [u8; {bytes}],",
                        index = pad_index,
                        bytes = bytes
                    )?;
                    pad_index += 1;
                }
                if let Some(_) = pad.align {
                    // NOTE(mickvangelderen): align property is not documented
                    // in the xproto xml specification and it seems like the
                    // padding already properly aligns the fields. Could verify
                    // this but that would mean recursively determining the
                    // sizes of the fields which would make this script a lot
                    // more complicated.
                    println!("cargo:warning=Ignored align on {}.", error_name);
                }
            }
        }
    }

    writeln!(
        out,
        r"}}
"
    )?;
    Ok(())
}

fn write_error_copy<W: io::Write>(out: &mut W, extra: &Extra, error_copy: &xproto::ErrorCopy) -> io::Result<()> {
    let code_name = format!("XCB_{}", error_copy.name.to_shouty_snake_case());
    let alias = format!("xcb_{}_error_t", error_copy.name.to_snake_case());
    let ty = format!("xcb_{}_error_t", error_copy.source.to_snake_case());
    writeln!(
        out,
        r##"pub const {code_name}: u8 = {code};

pub type {alias} = {ty};
"##,
        code_name = code_name,
        code = error_copy.code,
        alias = alias,
        ty = ty,
    )?;
    Ok(())
}
